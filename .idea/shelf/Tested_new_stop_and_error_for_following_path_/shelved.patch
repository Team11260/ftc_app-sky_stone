Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/hardware/devices/led/LedController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.mecanum.hardware.devices.led;\r\n\r\nimport org.firstinspires.ftc.teamcode.framework.util.SubsystemController;\r\n\r\npublic class LedController extends SubsystemController {\r\n\r\n\r\n    LedServo led;\r\n\r\n    static int cycle;\r\n\r\n\r\n    public LedController(){\r\n        led = new LedServo(hardwareMap);\r\n        this.ledOff();\r\n        cycle = 0;\r\n\r\n\r\n\r\n    }\r\n\r\n    public void ledOff(){\r\n        led.setLed1(0.51);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void setGreen(){\r\n        led.setLed1(0.2);\r\n\r\n\r\n\r\n    }\r\n\r\n    public void setRed(){\r\n        led.setLed1(0.8);\r\n\r\n    }\r\n\r\n    public void ledCycle(){\r\n        if(cycle == 0) {\r\n            this.setGreen();\r\n            cycle++;\r\n\r\n        }\r\n        else if(cycle == 1){\r\n            this.setRed();\r\n            cycle++;\r\n\r\n\r\n        }\r\n        else{\r\n            this.ledOff();\r\n            cycle = 0;\r\n\r\n\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    @Override\r\n    public void update() throws Exception {\r\n\r\n    }\r\n\r\n    @Override\r\n    public void stop() {\r\n\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/hardware/devices/led/LedController.java	(revision a6e8d7abddb208c5e6740b3da665368e8ce3bf8a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/hardware/devices/led/LedController.java	(date 1582168625623)
@@ -20,7 +20,7 @@
     }
 
     public void ledOff(){
-        led.setLed1(0.51);
+        led.setLed1(0.495);  // was 0.51
 
 
 
@@ -37,6 +37,10 @@
         led.setLed1(0.8);
 
     }
+    public void setLEDValue( double LEDValue )
+    {
+        led.setLed1(LEDValue);
+    }
 
     public void ledCycle(){
         if(cycle == 0) {
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/framework/userhardware/purepursuit/PursuitPath.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.framework.userhardware.purepursuit;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\n\r\n/**\r\n * PursuitPath is a class which stores points and calculates values to run pure pursuit\r\n *\r\n * @author Matthew Oates\r\n */\r\n\r\npublic class PursuitPath {\r\n\r\n    /**PursuitPath specific creation and following data*/\r\n\r\n    /**\r\n     * Distance between each point (inches)\r\n     */\r\n    private double fPointSpacing = 2;\r\n\r\n    /**\r\n     * The amount of smoothing to be done on the path (larger number = more smoothing)\r\n     */\r\n    private double fPathSmoothing = 0.8;\r\n\r\n    /**\r\n     * Speed reduction through turns (larger number = faster turns)\r\n     */\r\n    private double fTurnSpeed = 0.07;\r\n\r\n    /**\r\n     * Scales following speed based on tracking error (smaller number = better tracking, larger number = faster tracking)\r\n     */\r\n    private double fTrackingErrorSpeed = 5.0;\r\n\r\n    /**\r\n     * Scales how much turn error is added into total error\r\n     */\r\n    private double fTurnErrorScalar = 0.0;\r\n\r\n    /**\r\n     * The max acceleration (total output/point)\r\n     */\r\n    private double fMaxAcceleration = 0.08;\r\n\r\n    /**\r\n     * The max deceleration (total output/point)\r\n     */\r\n    private double fMaxDeceleration = 0.017;\r\n\r\n    /**\r\n     * Minimum follow speed\r\n     */\r\n    private double fMinSpeed = 0.17;\r\n\r\n    /**\r\n     * Maximum follow speed\r\n     */\r\n    private double fMaxSpeed = 1.0;\r\n\r\n    /**\r\n     * Average look ahead distance\r\n     */\r\n    private double fLookAheadDistance = 5;\r\n\r\n    /**\r\n     * Look ahead distance for velocity calculations\r\n     */\r\n    private int fVelocityLookAheadPoints = 1;\r\n\r\n    /**\r\n     * Position error that it allows\r\n     */\r\n    private double fPositionError = 2.0;\r\n\r\n    /**\r\n     * Heading error that it allows\r\n     */\r\n    private double fHeadingError = 5.0;\r\n\r\n    /**\r\n     * Run specific data, gets reset with reset() method\r\n     */\r\n\r\n    private int fLastPointIndex = 0;\r\n    private int fLastCurrentPointIndex = 0;\r\n    private double fTargetAngle = 0;\r\n    private double fDeltaAngle = 0;\r\n    private double fCurvature = 0.000001;\r\n    private double turnGain = 1.0;\r\n\r\n    /**\r\n     * Waypoints along path specified by behavior\r\n     */\r\n    private ArrayList<Point> fPoints;\r\n\r\n    /**\r\n     * All the points along the path, created from the waypoints (fPoints)\r\n     */\r\n    private ArrayList<PathPoint> fPath;\r\n\r\n    /**\r\n     * Pass in an ArrayList of waypoints\r\n     */\r\n    public PursuitPath(ArrayList<Point> points) {\r\n        fPoints = points;\r\n    }\r\n\r\n    /**\r\n     * Pass in a comma separated list or array of waypoints\r\n     */\r\n    public PursuitPath(Point... points) {\r\n        this(new ArrayList<>(Arrays.asList(points)));\r\n    }\r\n\r\n    /**\r\n     * Setters for path specific creation and following data\r\n     */\r\n\r\n    public PursuitPath setPointSpacing(double pointSpacing) {\r\n        fPointSpacing = pointSpacing;\r\n        return this;\r\n    }\r\n\r\n    public PursuitPath setPathSmoothing(double pathSmoothing) {\r\n        fPathSmoothing = pathSmoothing;\r\n        return this;\r\n    }\r\n\r\n    /*public void setTurnSpeed(double turnSpeed) {\r\n        fTurnSpeed = turnSpeed;\r\n    }*/\r\n\r\n    public PursuitPath setTurnGain(double turnGain){\r\n        this.turnGain = turnGain;\r\n        return this;\r\n    }\r\n\r\n    public double getTurnGain(){\r\n        return turnGain;\r\n    }\r\n\r\n    public PursuitPath setTurnSpeed(double turnSpeed) {\r\n        fTurnSpeed = turnSpeed;\r\n        return this;\r\n    }\r\n\r\n    public PursuitPath setTurnSpeedReturn(double turnSpeed) {\r\n        fTurnSpeed = turnSpeed;\r\n\r\n        return this;\r\n    }\r\n\r\n    public void setTrackingErrorSpeed(double trackingErrorSpeed) {\r\n        fTrackingErrorSpeed = trackingErrorSpeed;\r\n    }\r\n\r\n    public void setTurnErrorScalar(double turnErrorScalar) {\r\n        fTurnErrorScalar = turnErrorScalar;\r\n    }\r\n\r\n    public PursuitPath setMaxAcceleration(double maxAcceleration) {\r\n        fMaxAcceleration = maxAcceleration;\r\n        return this;\r\n    }\r\n\r\n    public PursuitPath setMaxDeceleration(double maxDeceleration) {\r\n        fMaxDeceleration = maxDeceleration;\r\n        return this;\r\n    }\r\n\r\n    public PursuitPath setMinSpeed(double minSpeed) {\r\n        fMinSpeed = minSpeed;\r\n        return this;\r\n    }\r\n\r\n    public PursuitPath setMaxSpeed(double maxSpeed) {\r\n        fMaxSpeed = maxSpeed;\r\n        return this;\r\n    }\r\n\r\n    public void setLookAheadDistance(double lookAheadDistance) {\r\n        fLookAheadDistance = lookAheadDistance;\r\n    }\r\n\r\n    public void setVelocityLookAheadPoints(int lookAheadPoints) {\r\n        fVelocityLookAheadPoints = lookAheadPoints;\r\n    }\r\n\r\n    public PursuitPath setPositionError(double positionError) {\r\n        fPositionError = positionError;\r\n        return this;\r\n    }\r\n\r\n    public PursuitPath setHeadingError(double headingError) {\r\n        fHeadingError = headingError;\r\n        return this;\r\n    }\r\n\r\n    public double getHeadingError() {\r\n        return fHeadingError;\r\n    }\r\n    /**\r\n     * Getters for path specific creation and following data\r\n     */\r\n\r\n    public double getPointSpacing() {\r\n        return fPointSpacing;\r\n    }\r\n\r\n    public double getPathSmoothing() {\r\n        return fPathSmoothing;\r\n    }\r\n\r\n    public double getTurnSpeed() {\r\n        return fTurnSpeed;\r\n    }\r\n\r\n    public double getTrackingErrorSpeed() {\r\n        return fTrackingErrorSpeed;\r\n    }\r\n\r\n    public double getTurnErrorScalar(double turnErrorScalar) {\r\n        return fTurnErrorScalar;\r\n    }\r\n\r\n    public double getMaxAcceleration() {\r\n        return fMaxAcceleration;\r\n    }\r\n\r\n    public double getMaxDeceleration() {\r\n        return fMaxDeceleration;\r\n    }\r\n\r\n    public double getMinSpeed() {\r\n        return fMinSpeed;\r\n    }\r\n\r\n    public double getMaxSpeed() {\r\n        return fMaxSpeed;\r\n    }\r\n\r\n    public double getLookAheadDistance() {\r\n        return fLookAheadDistance;\r\n    }\r\n\r\n    public int getVelocityLookAheadPoints() {\r\n        return fVelocityLookAheadPoints;\r\n    }\r\n\r\n    public double getPositionError(){\r\n        return fPositionError;\r\n    }\r\n    /**Methods for path following*/\r\n\r\n    /**\r\n     * Returns a single PathPoint from fPath\r\n     *\r\n     * @param index the index of the PathPoint\r\n     * @return a PathPoint\r\n     */\r\n    public PathPoint getPoint(int index) {\r\n        return getPathPoint(index);\r\n    }\r\n\r\n    /**\r\n     * Returns all points in path (fPath).\r\n     *\r\n     * @return a PathPoint ArrayList\r\n     */\r\n    public ArrayList<PathPoint> getPoints() {\r\n        if (fPath != null) {\r\n            return (ArrayList<PathPoint>) fPath.clone();\r\n        }\r\n        build();\r\n        return getPoints();\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the angle from the robots current pose to a specified point.\r\n     *\r\n     * @param index           the index of the point, usually the look ahead point\r\n     * @param currentLocation the current Pose2d of the robot\r\n     * @return the angle in degrees\r\n     */\r\n    public double getAngleFromPathPoint(int index, Pose currentLocation) {\r\n        if (fPath == null || fPath.size() == 0) return 0.0;\r\n\r\n        //Vector delta = new Vector(index < getPath().size() - 1 ? getPathPoint(index).subtract(currentLocation) : getPathPoint(getPath().size() - 1).add(new Vector(getPathPoint(getPath().size() - 1).subtract(getPathPoint(getPath().size() - 2))).normalize().scale(fLookAheadDistance - currentLocation.distance(getPathPoint(getPath().size() - 1)))).subtract(currentLocation));\r\n        Vector delta = new Vector(getPathPoint(index).subtract(currentLocation));\r\n\r\n//        double angle = Math.toDegrees(Math.atan2(delta.getY(), Math.abs(delta.getX()) > 0.3 ? delta.getX() : 0.3 * Math.signum(delta.getX())));\r\n        double angle = Math.toDegrees(Math.atan2(delta.getY(), delta.getX()));\r\n\r\n        fTargetAngle = angle;\r\n\r\n        return angle;\r\n    }\r\n\r\n\r\n    /**\r\n     * Calculates and returns the curvature from the robots current pose to a specified point,\r\n     * used by the follower to steer the robot.\r\n     *\r\n     * @param index           the index of the point, usually the look ahead point\r\n     * @param currentLocation the current Pose2d of the robot\r\n     * @return the curvature represent as 1 / radius of the circle made by the amount of curvature\r\n     */\r\n    public double getCurvatureFromPathPoint(int index, Pose currentLocation) {\r\n        if (fPath == null || fPath.size() == 0) return 0.0;\r\n\r\n        Vector delta = new Vector(index < getPath().size() - 1 ? getPathPoint(index).subtract(currentLocation) : getPathPoint(getPath().size() - 1).add(new Vector(getPathPoint(getPath().size() - 1).subtract(getPathPoint(getPath().size() - 2))).normalize().scale(fLookAheadDistance - currentLocation.distance(getPathPoint(getPath().size() - 1)))).subtract(currentLocation));\r\n\r\n        double angle = Math.toDegrees(Math.atan2(delta.getY(), Math.abs(delta.getX()) > 0.3 ? delta.getX() : 0.3 * Math.signum(delta.getX())));\r\n\r\n        fTargetAngle = angle;\r\n\r\n        fDeltaAngle = currentLocation.getHeading() - angle;\r\n\r\n        if (Math.abs(fDeltaAngle) > 180)\r\n            fDeltaAngle = -Math.signum(fDeltaAngle) * (360 - Math.abs(fDeltaAngle));\r\n\r\n        double curvature = (Math.abs(fDeltaAngle) > 90 ? Math.signum(fDeltaAngle) : Math.sin(Math.toRadians(fDeltaAngle))) / (delta.magnitude() / 2);\r\n\r\n        if (Double.isInfinite(curvature) || Double.isNaN(curvature)) return 0.0;\r\n\r\n        fCurvature = curvature;\r\n\r\n        return curvature;\r\n    }\r\n\r\n    /**\r\n     * Returns the last target angle of the robot,\r\n     * calculated by getCurvatureFromPathPoint.\r\n     * Used mainly for debugging.\r\n     *\r\n     * @return the last target angle\r\n     */\r\n    public double getTargetAngle() {\r\n        return fTargetAngle;\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the optimal velocity of the robot at its current position,\r\n     * used by the follower to drive the robot.\r\n     * Calculates the speed of upcoming points using curvature and tracking error, then picks the slowest.\r\n     * This ensures we slow down in advance for turns, preventing overshoot.\r\n     *\r\n     * @param index           the index of the point closest to the robot\r\n     * @param currentLocation the current Pose2d of the robot\r\n     * @return the velocity\r\n     */\r\n    public double getPathPointVelocity(int index, Pose currentLocation) {\r\n        double speed = fMaxSpeed;\r\n        for (int i = index; i < index + fVelocityLookAheadPoints && i < getPoints().size(); i++) {\r\n            speed = Math.min(speed, range(getPathPoint(i).getVelocity() / range(getTrackingError(currentLocation) / fTrackingErrorSpeed, 1, 3), fMinSpeed, fMaxSpeed));\r\n        }\r\n        return speed;\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the index of the point on the path (fPath) closest to the robots current position,\r\n     * can then be passed into other methods to calculate following values.\r\n     *\r\n     * @param currentPosition the current Point of the robot\r\n     * @return the index of the closest point\r\n     */\r\n    public int getClosestPointIndex(Point currentPosition) {\r\n        if (fPath == null || fPath.size() == 0) return -1;\r\n\r\n        double distance = 1000000;\r\n        int index = -1;\r\n\r\n        for (int i = fLastCurrentPointIndex; i < getPath().size(); i++) {\r\n            if (currentPosition.distance(getPathPoint(i)) < distance) {\r\n                index = i;\r\n                distance = currentPosition.distance(getPathPoint(i));\r\n            }\r\n        }\r\n\r\n        fLastCurrentPointIndex = index;\r\n\r\n        if (fLastCurrentPointIndex < 0) {\r\n            fLastCurrentPointIndex = 0;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the index of the pure pursuit look ahead point,\r\n     * can then be passed into other methods to calculate following values.\r\n     *\r\n     * @param currentPosition the current Point of the robot\r\n     * @return the index of the look ahead point\r\n     */\r\n    public int getLookAheadPointIndex(Pose currentPosition) {\r\n        if (fPath == null || fPath.size() == 0) return -1;\r\n\r\n        int closest = getClosestPointIndex(currentPosition);\r\n\r\n        for (int i = getClosestPointIndex(currentPosition); i < getPath().size(); i++) {\r\n            fCurvature = Math.abs(getCurvatureFromPathPoint(i, currentPosition));\r\n\r\n            double correction = range(fCurvature, 1, 5);\r\n\r\n            double curvature = 0;\r\n\r\n            for (int p = closest; p <= i; p++) {\r\n                curvature += getPointCurvature(closest);\r\n            }\r\n\r\n            if (getPointDistance(i) - getPointDistance(closest) > fLookAheadDistance / range(curvature / 3, 1, 2)) {\r\n                fLastPointIndex = i;\r\n                return i;\r\n            }\r\n        }\r\n\r\n        if (closest != getPath().size() - 1) return getPath().size() - 1;\r\n\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns straight line distance between the robot and the closest point on the path (fPath),\r\n     * used by getPathPointVelocity to slow the following speed if the robot is far off the path.\r\n     *\r\n     * @param currentPosition the current Point of the robot\r\n     * @return the index of the look ahead point\r\n     */\r\n    public double getTrackingError(Point currentPosition) {\r\n        return getPathPoint(getClosestPointIndex(currentPosition)).distance(currentPosition) + Math.abs(fDeltaAngle * fTurnErrorScalar);\r\n    }\r\n\r\n    /**Methods creating and clearing the path*/\r\n\r\n    /**\r\n     * Resets all the run specific data, so a single path can be run more than once.\r\n     */\r\n    public void reset() {\r\n        fLastPointIndex = 0;\r\n        fLastCurrentPointIndex = 0;\r\n        fTargetAngle = 0;\r\n        fDeltaAngle = 0;\r\n        fCurvature = 0.000001;\r\n    }\r\n\r\n    /**\r\n     * Returns a single PathPoint from fPath\r\n     *\r\n     * @param point the index of the PathPoint\r\n     * @return a PathPoint\r\n     */\r\n    private PathPoint getPathPoint(int point) {\r\n        if (fPath != null) {\r\n            return fPath.get(point);\r\n        }\r\n        build();\r\n        return getPathPoint(point);\r\n    }\r\n\r\n    /**\r\n     * Returns all points in path (fPath).\r\n     *\r\n     * @return a PathPoint ArrayList\r\n     */\r\n    private ArrayList<PathPoint> getPath() {\r\n        if (fPath != null) {\r\n            return fPath;\r\n        }\r\n        build();\r\n        return getPath();\r\n    }\r\n\r\n    /**\r\n     * Turns all the waypoints (fPoints) into a path (fPath).\r\n     */\r\n    public void build() {\r\n\r\n        if (fPath != null) {\r\n            return;\r\n        }\r\n\r\n        if (fPoints.size() == 0) {\r\n            fPath = new ArrayList<>();\r\n            return;\r\n        }\r\n\r\n        fill();\r\n\r\n        smooth();\r\n\r\n        createPath();\r\n    }\r\n\r\n    /**\r\n     * Fills the spaces between waypoints (fPoints) with a point fPointSpacing inches.\r\n     */\r\n    private void fill() {\r\n        ArrayList<Point> newPoints = new ArrayList<>();\r\n\r\n        for (int s = 1; s < fPoints.size(); s++) {\r\n            Vector vector = new Vector(fPoints.get(s - 1), fPoints.get(s));\r\n\r\n            int numPointsFit = (int) Math.ceil(vector.magnitude() / fPointSpacing);\r\n\r\n            vector = vector.normalize().scale(fPointSpacing);\r\n\r\n            for (int i = 0; i < numPointsFit; i++) {\r\n                newPoints.add(fPoints.get(s - 1).add(vector.scale(i)));\r\n            }\r\n        }\r\n\r\n        newPoints.add(fPoints.get(fPoints.size() - 1));\r\n\r\n        fPoints = newPoints;\r\n    }\r\n\r\n    /**\r\n     * Smooths the straight lines of points into a curved path.\r\n     */\r\n    private void smooth() {\r\n        double change = 0.5;\r\n        double changedPoints = 1;\r\n        while (change / changedPoints >= 0.01) {\r\n            change = 0;\r\n            changedPoints = 0;\r\n\r\n            ArrayList<Point> newPoints = (ArrayList<Point>) fPoints.clone();\r\n\r\n            for (int i = 1; i < fPoints.size() - 1; i++) {\r\n                Point point = fPoints.get(i);\r\n\r\n                Vector middle = new Vector(fPoints.get(i + 1).subtract(fPoints.get(i - 1)));\r\n\r\n                middle = new Vector(fPoints.get(i - 1).add(middle.normalize().scale(middle.magnitude() / 2)));\r\n\r\n                Vector delta = new Vector(middle.subtract(point));\r\n\r\n                Point newPoint = point.add(delta.normalize().scale(delta.magnitude() * fPathSmoothing));\r\n\r\n                if (!Double.isNaN(newPoint.getX()) && !Double.isNaN(newPoint.getY())) {\r\n                    newPoints.set(i, newPoint);\r\n                    change += point.distance(newPoint);\r\n                    changedPoints++;\r\n                }\r\n            }\r\n            fPoints = newPoints;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates a target velocity and curvature for every point on the path.\r\n     */\r\n    private void createPath() {\r\n\r\n        fPath = new ArrayList<>();\r\n\r\n        for (int p = 0; p < fPoints.size(); p++) {\r\n            fPath.add(new PathPoint(fPoints.get(p), getPointDistance(p), getPointCurvature(p), getPointVelocity(p)));\r\n        }\r\n\r\n        for (int p = fPoints.size() - 2; p >= 0; p--) {\r\n            getPathPoint(p).setVelocity(getPointNewVelocity(p));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the distance a point is along the path.\r\n     *\r\n     * @param p the index of the point\r\n     * @return the distance the point is along the path\r\n     */\r\n    private double getPointDistance(int p) {\r\n        if (p == 0) return 0.0;\r\n        return fPoints.get(p).distance(fPoints.get(p - 1)) + getPathPoint(p - 1).getDistance();\r\n    }\r\n\r\n    /**\r\n     * Returns the curvature of the path at a point,\r\n     * uses the getCurvature method.\r\n     * Used by the getPointVelocity method.\r\n     *\r\n     * @param p the index of the point\r\n     * @return the curvature of the path at the point, represent as 1 / radius of the circle made by the amount of curvature\r\n     */\r\n    private double getPointCurvature(int p) {\r\n        if (p <= 0 || p >= fPoints.size() - 1) return 0.0;\r\n        return getCurvature(fPoints.get(p), fPoints.get(p - 1), fPoints.get(p + 1));\r\n    }\r\n\r\n    /**\r\n     * Returns the curvature between three points,\r\n     * by fitting a circle to the points.\r\n     *\r\n     * @param p1 the index of the first point\r\n     * @param p2 the index of the second point\r\n     * @param p3 the index of the third point\r\n     * @return the curvature represent as 1 / radius of the circle made by the amount of curvature\r\n     */\r\n    private double getCurvature(Point p1, Point p2, Point p3) {\r\n        double x1 = p1.getX(), y1 = p1.getY();\r\n        double x2 = p2.getX(), y2 = p2.getY();\r\n        double x3 = p3.getX(), y3 = p3.getY();\r\n        if (x1 == x2) x1 += 0.0001;\r\n        double k1 = 0.5 * (Math.pow(x1, 2) + Math.pow(y1, 2) - Math.pow(x2, 2) - Math.pow(y2, 2)) / (x1 - x2);\r\n        double k2 = (y1 - y2) / (x1 - x2);\r\n        double b = 0.5 * (Math.pow(x2, 2) - 2 * x2 * k1 + Math.pow(y2, 2) - Math.pow(x3, 2) + 2 * x3 * k1 - Math.pow(y3, 2)) / (x3 * k2 - y3 + y2 - x2 * k2);\r\n        double a = k1 - k2 * b;\r\n        double r = Math.sqrt(Math.pow(x1 - a, 2) + Math.pow(y1 - b, 2));\r\n        double c = 1 / r;\r\n        if (Double.isNaN(c)) {\r\n            return 0.0;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * Returns the first calculation velocity of the path at a point,\r\n     * calculated using the amount of curvature at the point.\r\n     * Uses the getPointCurvature method.\r\n     *\r\n     * @param p the index of the point\r\n     * @return the first calculation of velocity\r\n     */\r\n    private double getPointVelocity(int p) {\r\n        if (p >= fPoints.size() - 2) return fMinSpeed;\r\n\r\n        double d = fPoints.get(p).distance(fPoints.get(p + 1));\r\n\r\n        if (p <= 0)\r\n            return Math.max(Math.min(2 * fMaxAcceleration * d, fTurnSpeed / getPointCurvature(p)), fMinSpeed);\r\n\r\n        return Math.max(Math.min(getPathPoint(p - 1).getVelocity() + 2 * fMaxAcceleration * d, Math.min(fTurnSpeed / getPointCurvature(p), fMaxSpeed)), fMinSpeed);\r\n    }\r\n\r\n    /**\r\n     * Returns the second/final calculation of the velocity of the path at a point,\r\n     * calculated using fMaxAcceleration, and the speed at nearby points,\r\n     * to make smooth and consistent acceleration and deceleration.\r\n     *\r\n     * @param p the index of the point\r\n     * @return the second/final calculation of velocity\r\n     */\r\n    private double getPointNewVelocity(int p) {\r\n        if (p >= fPoints.size() - 2) return fMinSpeed;\r\n\r\n        double d = fPoints.get(p).distance(fPoints.get(p + 1));\r\n\r\n        return Math.min(getPathPoint(p).getVelocity(), Math.min(getPathPoint(p + 1).getVelocity() + 2 * fMaxDeceleration * d, fMaxSpeed));\r\n    }\r\n\r\n    /**\r\n     * Returns number in the bounds of min and max\r\n     *\r\n     * @param number the initial number\r\n     * @param min    the lower bound of the return value\r\n     * @param max    the upper bound of the return value\r\n     * @return the bounded number\r\n     */\r\n    private double range(double number, double min, double max) {\r\n        if (number < min) {\r\n            return min;\r\n        }\r\n        if (number > max) {\r\n            return max;\r\n        }\r\n        return number;\r\n    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/framework/userhardware/purepursuit/PursuitPath.java	(revision a6e8d7abddb208c5e6740b3da665368e8ce3bf8a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/framework/userhardware/purepursuit/PursuitPath.java	(date 1582505914418)
@@ -631,7 +631,9 @@
         if (p <= 0)
             return Math.max(Math.min(2 * fMaxAcceleration * d, fTurnSpeed / getPointCurvature(p)), fMinSpeed);
 
-        return Math.max(Math.min(getPathPoint(p - 1).getVelocity() + 2 * fMaxAcceleration * d, Math.min(fTurnSpeed / getPointCurvature(p), fMaxSpeed)), fMinSpeed);
+        return Math.max(Math.min(getPathPoint(p - 1).getVelocity() + 2 * fMaxAcceleration * d,
+                        Math.min(fTurnSpeed / getPointCurvature(p), fMaxSpeed)),
+                fMinSpeed);
     }
 
     /**
@@ -647,7 +649,9 @@
 
         double d = fPoints.get(p).distance(fPoints.get(p + 1));
 
-        return Math.min(getPathPoint(p).getVelocity(), Math.min(getPathPoint(p + 1).getVelocity() + 2 * fMaxDeceleration * d, fMaxSpeed));
+        return Math.min(getPathPoint(p).getVelocity(),
+                Math.min(getPathPoint(p + 1).getVelocity() + 2 * fMaxDeceleration * d, fMaxSpeed)
+        );
     }
 
     /**
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/auton/CalibrationAuto.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/auton/CalibrationAuto.java	(date 1582505914396)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/auton/CalibrationAuto.java	(date 1582505914396)
@@ -0,0 +1,113 @@
+package org.firstinspires.ftc.teamcode.mecanum.opmodes.auton;
+
+import com.qualcomm.robotcore.eventloop.opmode.Autonomous;
+import com.qualcomm.robotcore.util.ElapsedTime;
+
+import org.firstinspires.ftc.teamcode.framework.abstractopmodes.AbstractAuton;
+import org.firstinspires.ftc.teamcode.framework.userhardware.DoubleTelemetry;
+import org.firstinspires.ftc.teamcode.framework.userhardware.paths.Path;
+import org.firstinspires.ftc.teamcode.framework.userhardware.paths.PurePursuitSegment;
+import org.firstinspires.ftc.teamcode.framework.userhardware.purepursuit.Point;
+import org.firstinspires.ftc.teamcode.framework.userhardware.purepursuit.PursuitPath;
+import org.firstinspires.ftc.teamcode.mecanum.hardware.Robot;
+
+@Autonomous(name = "Calibration", group = "New")
+
+public class CalibrationAuto extends AbstractAuton {
+
+    Robot robot;
+
+
+    @Override
+    public void RegisterStates() {
+
+    }
+
+    @Override
+    public void Init() {
+
+
+        robot = new Robot();
+        robot.arm.setArmUpPosition();
+        robot.arm.setGripperGripPosition();
+        robot.lift.setTiltUp();
+        robot.dragger.setDraggerUp();
+
+
+    }
+
+    @Override
+    public void Run() {
+
+        ElapsedTime time = new ElapsedTime();
+
+        time.reset();
+
+
+       robot.runDrivePath(Calibration());
+//        robot.setDrivePowerAll(-0.8,-0.8,-0.8,-0.8);
+//
+//        delay(1000);
+//
+//        robot.setDrivePowerAll(0,0,0,0);
+//
+//        delay(100);
+//
+//        robot.setDrivePowerAll(-0.8,-0.8,-0.8,-0.8);
+//
+//        delay(800);
+//
+//        robot.setDrivePowerAll(0,0,0,0);
+
+
+
+
+
+
+        telemetry.addData(DoubleTelemetry.LogMode.INFO, "x: " + robot.driver.getCurrentPosition().getX() +
+                " y: " + robot.driver.getCurrentPosition().getY());
+
+        telemetry.addData(DoubleTelemetry.LogMode.INFO, "total time: " + time.milliseconds() / 1000);
+
+        telemetry.update();
+
+        delay(10000);
+
+
+    }
+
+
+    protected Path Calibration() {
+        Path CalibrationPath = new Path("Calibration");
+
+        CalibrationPath.addSegment(new PurePursuitSegment("First Curve",
+                new PursuitPath(
+
+                        new Point(0, 0),
+                        new Point(0, 6),
+                        new Point(-86, 6),
+                        new Point(-86, 0)
+                ).setMaxDeceleration(0.013)
+
+
+        ));
+
+        CalibrationPath.addSegment(new PurePursuitSegment("Second Curve",
+                new PursuitPath(
+                        new Point(-86, 0),
+                        new Point(-86, 6),
+                        new Point(0, 6),
+                        new Point(0, 0)
+
+
+                ).setMaxDeceleration(0.013)
+
+        ));
+
+        return CalibrationPath;
+
+
+    }
+
+
+}
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/framework/userhardware/purepursuit/MecanumPurePursuitController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.framework.userhardware.purepursuit;\r\n\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.DoubleTelemetry;\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.PIDController;\r\n\r\nimport static org.firstinspires.ftc.teamcode.framework.userhardware.DoubleTelemetry.LogMode.INFO;\r\n\r\npublic abstract class MecanumPurePursuitController extends PurePursuitController {\r\n\r\n    protected double lastXPosition = 0, lastYPosition = 0;\r\n\r\n    protected double positionError = 4.0, headingError = 5.0;\r\n\r\n    protected final double yScale;\r\n\r\n    protected double targetHeading = 0.0;\r\n\r\n    protected double nextDistance = 0.0;\r\n\r\n    protected HeadingMode headingMode = HeadingMode.FIXED;\r\n\r\n    private PIDController headingController;\r\n\r\n    public MecanumPurePursuitController(double trackWidth, double yScale, PIDController headingController, DoubleTelemetry telemetry) {\r\n        super(trackWidth, telemetry);\r\n\r\n        this.yScale = yScale;\r\n\r\n        this.headingController = headingController;\r\n    }\r\n\r\n    public void setTargetHeading(double targetHeading) {\r\n        this.targetHeading = targetHeading;\r\n    }\r\n\r\n    public void setHeadingMode(HeadingMode headingMode) {\r\n        this.headingMode = headingMode;\r\n    }\r\n\r\n    public void setPositionError(double positionError){\r\n        this.positionError = positionError;\r\n    }\r\n\r\n    @Override\r\n    public void follow(PursuitPath pursuitPath) {\r\n        super.follow(pursuitPath);\r\n\r\n        headingController.reset();\r\n    }\r\n\r\n    @Override\r\n    public void updatePose() {\r\n\r\n        double xPosition = getXActualPositionInches();\r\n        double yPosition = getYActualPositionInches();\r\n\r\n\r\n        double heading = getActualHeadingDegrees();\r\n\r\n        double xDistance = xPosition - lastXPosition;\r\n        double yDistance = yPosition - lastYPosition;\r\n\r\n        double x = Math.cos(Math.toRadians(heading));\r\n        double y = Math.sin(Math.toRadians(heading));\r\n\r\n\r\n        telemetry.getSmartdashboard().putGraph(\"position\", \"Heading\", xPosition, heading);\r\n        telemetry.getSmartdashboard().putGraph(\"position\", \"scalars\", x, y);\r\n\r\n        currentPosition = new Pose(currentPosition.add(new Vector(xDistance * x, xDistance * y)).add(new Vector(-yDistance * y, yDistance * x)), heading);\r\n\r\n        lastXPosition = xPosition;\r\n        lastYPosition = yPosition;\r\n\r\n        nextDistance = new Vector(xDistance,yDistance).magnitude();\r\n    }\r\n\r\n    @Override\r\n    public void updateFollower() {\r\n        if(headingMode == HeadingMode.DYNAMIC) {\r\n            super.updateFollower();\r\n            return;\r\n        }\r\n\r\n        if(!isFollowing()) return;\r\n\r\n        int lookahead = currentPursuitPath.getLookAheadPointIndex(currentPosition);\r\n        int closest = currentPursuitPath.getClosestPointIndex(currentPosition);\r\n\r\n        if(lookahead == -1) {\r\n            isFollowing = false;\r\n            lookahead = currentPursuitPath.getPoints().size() - 1;\r\n        }\r\n        Vector delta = new Vector(currentPursuitPath.getPoint(lookahead).subtract(currentPosition));\r\n\r\n        double velocity = currentPursuitPath.getPathPointVelocity(closest, currentPosition);\r\n        double angle = currentPursuitPath.getAngleFromPathPoint(lookahead, currentPosition) - currentPosition.getHeading();\r\n\r\n        double x = Math.cos(Math.toRadians(angle));\r\n        double y = Math.sin(Math.toRadians(angle)) * yScale;\r\n        double z = currentPursuitPath.getTurnGain() * headingController.output(targetHeading, currentPosition.getHeading());\r\n\r\n\r\n        //telemetry.getSmartdashboard().putGraph(\"Position\",\"Target Heading\", closest ,angle);\r\n\r\n        double frontLeft = velocity * (x - y - z);\r\n        double frontRight = velocity * (x + y + z);\r\n        double backLeft = velocity * (x + y - z);\r\n        double backRight = velocity * (x - y + z);\r\n\r\n//        telemetry.getSmartdashboard().putGraph(\"outputs\",\"x\", closest ,x);\r\n//        telemetry.getSmartdashboard().putGraph(\"outputs\",\"y\", closest ,y);\r\n//        telemetry.getSmartdashboard().putGraph(\"outputs\",\"z\", closest ,z);\r\n\r\n\r\n\r\n//        telemetry.addData(INFO,\"heading: \" + currentPosition.getHeading());\r\n//        telemetry.addData(INFO,\"x position: \" + currentPosition.getX());\r\n//        telemetry.addData(INFO,\"y position: \" + currentPosition.getY());\r\n//        telemetry.addData(INFO,\" \" );\r\n//        telemetry.update();\r\n\r\n        setMecanumPower(frontLeft, frontRight, backLeft, backRight);\r\n    }\r\n\r\n    public double getDistance(){\r\n        return nextDistance;\r\n    }\r\n\r\n    @Override\r\n    public boolean isFollowing() {\r\n        return currentPursuitPath != null && (isFollowing || Math.abs(currentPosition.getHeading() - targetHeading) > currentPursuitPath.getHeadingError() || currentPosition.distance(currentPursuitPath.getPoint(currentPursuitPath.getPoints().size() - 1)) > currentPursuitPath.getPositionError());\r\n    }\r\n\r\n    @Override\r\n    public void resetPosition() {\r\n        super.resetPosition();\r\n\r\n        lastXPosition = 0;\r\n        lastYPosition = 0;\r\n    }\r\n\r\n    @Override\r\n    public final double getLeftActualPositionInches() {\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    public final double getRightActualPositionInches() {\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    public void setPower(double l, double r) {\r\n        setMecanumPower(l, r, l, r);\r\n    }\r\n\r\n    public abstract double getXActualPositionInches();\r\n\r\n    public abstract double getYActualPositionInches();\r\n\r\n    public abstract void setMecanumPower(double fl, double fr, double bl, double br);\r\n\r\n    public enum HeadingMode {\r\n        FIXED,\r\n        DYNAMIC\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/framework/userhardware/purepursuit/MecanumPurePursuitController.java	(revision a6e8d7abddb208c5e6740b3da665368e8ce3bf8a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/framework/userhardware/purepursuit/MecanumPurePursuitController.java	(date 1582505914439)
@@ -129,7 +129,13 @@
 
     @Override
     public boolean isFollowing() {
-        return currentPursuitPath != null && (isFollowing || Math.abs(currentPosition.getHeading() - targetHeading) > currentPursuitPath.getHeadingError() || currentPosition.distance(currentPursuitPath.getPoint(currentPursuitPath.getPoints().size() - 1)) > currentPursuitPath.getPositionError());
+        return currentPursuitPath != null && (isFollowing || Math.abs(currentPosition.getHeading() - targetHeading)
+                > currentPursuitPath.getHeadingError()
+                || currentPosition.distance(currentPursuitPath.getPoint(currentPursuitPath.getPoints().size() - 1))
+                > currentPursuitPath.getPositionError()
+                || currentPosition.getXDistance(currentPursuitPath.getPoint(currentPursuitPath.getPoints().size() - 1))
+                > currentPursuitPath.getPositionError()
+        );
     }
 
     @Override
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/cfg_files/boggie_base.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/cfg_files/boggie_base.xml	(date 1568583806000)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/cfg_files/boggie_base.xml	(date 1568583806000)
@@ -0,0 +1,22 @@
+<?xml version='1.0' encoding='UTF-8' standalone='yes' ?>
+<Robot type="FirstInspires-FTC">
+    <Webcam name="Webcam 1" serialNumber="88B5B26E" />
+    <LynxUsbDevice name="Expansion Hub Portal 1" serialNumber="DQ2CLQA7" parentModuleAddress="1">
+        <LynxModule name="Expansion Hub 1" port="1">
+            <NeveRest20Gearmotor name="left" port="0" />
+            <NeveRest20Gearmotor name="right" port="1" />
+            <NeveRest40Gearmotor name="robot_lift" port="2" />
+            <NeveRest20Gearmotor name="mineral_lift " port="3" />
+            <Servo name="mineral_gate" port="0" />
+            <Servo name="servo_marker" port="1" />
+            <RevSPARKMini name="intake" port="2" />
+            <Servo name="sorter_angle" port="3" />
+            <Servo name="lift_pawl" port="4" />
+            <RevSPARKMini name="light" port="5" />
+            <AnalogInput name="Pot" port="0" />
+            <AnalogInput name="lift_bottom_limit" port="3" />
+            <REV_VL53L0X_RANGE_SENSOR name="Distance1" port="0" bus="2" />
+            <LynxEmbeddedIMU name="imu" port="0" bus="0" />
+        </LynxModule>
+    </LynxUsbDevice>
+</Robot>
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/framework/userhardware/purepursuit/Point.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.framework.userhardware.purepursuit;\r\n\r\npublic class Point {\r\n\r\n    protected final double x, y;\r\n\r\n    public Point(double x, double y) {\r\n        this.x = x;\r\n        this.y = y;\r\n    }\r\n\r\n    public double getX() {\r\n        return x;\r\n    }\r\n\r\n    public double getY() {\r\n        return y;\r\n    }\r\n\r\n    public Point add(Vector vector) {\r\n        return new Point(getX() + vector.getX(), getY() + vector.getY());\r\n    }\r\n\r\n    public Point add(Point point) {\r\n        return new Point(getX() + point.getX(), getY() + point.getY());\r\n    }\r\n\r\n    public Point subtract(Point point) {\r\n        return new Point(getX() - point.getX(), getY() - point.getY());\r\n    }\r\n\r\n    public double distance(Point point) {\r\n        return Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));\r\n    }\r\n\r\n    public String toString() {\r\n        return \"(\" + String.format(\"%.4f\", x) + \",\" + String.format(\"%.4f\", y) + \")\";\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/framework/userhardware/purepursuit/Point.java	(revision a6e8d7abddb208c5e6740b3da665368e8ce3bf8a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/framework/userhardware/purepursuit/Point.java	(date 1582505914380)
@@ -33,6 +33,21 @@
         return Math.sqrt(Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2));
     }
 
+    public double getXDistance(Point point){
+        return  Math.abs(point.x-x);
+
+
+    }
+
+
+    public double getYDistance(Point point){
+        return  Math.abs(point.y-y);
+
+
+    }
+
+
+
     public String toString() {
         return "(" + String.format("%.4f", x) + "," + String.format("%.4f", y) + ")";
     }
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/cfg_files/mecanum_old_base.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version='1.0' encoding='UTF-8' standalone='yes' ?>\r\n<Robot type=\"FirstInspires-FTC\">\r\n    <Webcam name=\"WebCam\" serialNumber=\"88B5B26E\" />\r\n    <LynxUsbDevice name=\"Expansion Hub Portal 1\" serialNumber=\"DQ2CFUSD\" parentModuleAddress=\"2\">\r\n        <LynxModule name=\"Expansion Hub 2\" port=\"2\">\r\n            <RevRobotics20HDHexMotor name=\"back_right\" port=\"0\" />\r\n            <RevRobotics20HDHexMotor name=\"back_left\" port=\"1\" />\r\n            <RevRobotics20HDHexMotor name=\"front_right\" port=\"2\" />\r\n            <RevRobotics20HDHexMotor name=\"front_left\" port=\"3\" />\r\n            <Servo name=\"arm_servo\" port=\"0\" />\r\n            <Servo name=\"gripper_servo\" port=\"1\" />\r\n            <Servo name=\"right_intake\" port=\"2\" />\r\n            <Servo name=\"left_intake\" port=\"3\" />\r\n            <Servo name=\"conveyor_belt\" port=\"4\" />\r\n            <Servo name=\"back_dragger_servo\" port=\"5\" />\r\n            <DigitalDevice name=\"digital_touch\" port=\"0\" />\r\n            <LynxEmbeddedIMU name=\"imu\" port=\"0\" bus=\"0\" />\r\n            <LynxColorSensor name=\"color_distance\" port=\"0\" bus=\"3\" />\r\n        </LynxModule>\r\n        <LynxModule name=\"Expansion Hub 3\" port=\"3\">\r\n            <RevRobotics20HDHexMotor name=\"straight_encoder\" port=\"0\" />\r\n            <RevRobotics20HDHexMotor name=\"strafe_encoder\" port=\"1\" />\r\n            <RevRobotics20HDHexMotor name=\"lift\" port=\"2\" />\r\n            <Servo name=\"tilt_servo\" port=\"0\" />\r\n            <Servo name=\"pan_servo\" port=\"1\" />\r\n            <Servo name=\"slide_servo\" port=\"2\" />\r\n            <Servo name=\"grabber_servo\" port=\"3\" />\r\n            <Servo name=\"front_dragger_servo\" port=\"4\" />\r\n            <LynxEmbeddedIMU name=\"imu 1\" port=\"0\" bus=\"0\" />\r\n        </LynxModule>\r\n    </LynxUsbDevice>\r\n</Robot>\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/cfg_files/mecanum_old_base.xml	(revision a6e8d7abddb208c5e6740b3da665368e8ce3bf8a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/cfg_files/mecanum_old_base.xml	(date 1577424197000)
@@ -7,25 +7,24 @@
             <RevRobotics20HDHexMotor name="back_left" port="1" />
             <RevRobotics20HDHexMotor name="front_right" port="2" />
             <RevRobotics20HDHexMotor name="front_left" port="3" />
-            <Servo name="arm_servo" port="0" />
+            <Servo name="tilt_servo" port="0" />
             <Servo name="gripper_servo" port="1" />
-            <Servo name="right_intake" port="2" />
-            <Servo name="left_intake" port="3" />
+            <Servo name="led_one" port="2" />
+            <Servo name="right_intake" port="3" />
             <Servo name="conveyor_belt" port="4" />
             <Servo name="back_dragger_servo" port="5" />
-            <DigitalDevice name="digital_touch" port="0" />
             <LynxEmbeddedIMU name="imu" port="0" bus="0" />
-            <LynxColorSensor name="color_distance" port="0" bus="3" />
         </LynxModule>
         <LynxModule name="Expansion Hub 3" port="3">
             <RevRobotics20HDHexMotor name="straight_encoder" port="0" />
             <RevRobotics20HDHexMotor name="strafe_encoder" port="1" />
             <RevRobotics20HDHexMotor name="lift" port="2" />
-            <Servo name="tilt_servo" port="0" />
+            <Servo name="arm_servo" port="0" />
             <Servo name="pan_servo" port="1" />
             <Servo name="slide_servo" port="2" />
             <Servo name="grabber_servo" port="3" />
             <Servo name="front_dragger_servo" port="4" />
+            <Servo name="clamp_servo" port="5" />
             <LynxEmbeddedIMU name="imu 1" port="0" bus="0" />
         </LynxModule>
     </LynxUsbDevice>
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/cfg_files/Craig 1.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version='1.0' encoding='UTF-8' standalone='yes' ?>\r\n<Robot type=\"FirstInspires-FTC\">\r\n    <LynxUsbDevice name=\"Expansion Hub Portal 1\" serialNumber=\"DQ2CFRL5\" parentModuleAddress=\"1\">\r\n        <LynxModule name=\"Expansion Hub 1\" port=\"1\">\r\n            <RevRobotics20HDHexMotor name=\"front_left\" port=\"0\" />\r\n            <RevRobotics20HDHexMotor name=\"back_left\" port=\"1\" />\r\n            <RevRobotics20HDHexMotor name=\"front_right\" port=\"2\" />\r\n            <RevRobotics20HDHexMotor name=\"back_right\" port=\"3\" />\r\n            <Servo name=\"clamp_servo\" port=\"0\" />\r\n            <Servo name=\"right_intake\" port=\"1\" />\r\n            <Servo name=\"gripper_servo\" port=\"2\" />\r\n            <Servo name=\"left_intake\" port=\"3\" />\r\n            <Servo name=\"conveyor_belt\" port=\"4\" />\r\n            <Servo name=\"arm_servo\" port=\"5\" />\r\n            <LynxEmbeddedIMU name=\"imu\" port=\"0\" bus=\"0\" />\r\n        </LynxModule>\r\n        <LynxModule name=\"Expansion Hub 2\" port=\"2\">\r\n            <NeveRest20Gearmotor name=\"lift\" port=\"0\" />\r\n            <RevRobotics20HDHexMotor name=\"straight_encoder\" port=\"1\" />\r\n            <RevRobotics20HDHexMotor name=\"strafe_encoder\" port=\"2\" />\r\n            <Servo name=\"pan_servo\" port=\"0\" />\r\n            <Servo name=\"grabber_servo\" port=\"1\" />\r\n            <Servo name=\"tilt_servo\" port=\"2\" />\r\n            <Servo name=\"slide_servo\" port=\"3\" />\r\n            <Servo name=\"back_dragger_servo\" port=\"4\" />\r\n            <Servo name=\"front_dragger_servo\" port=\"5\" />\r\n            <LynxEmbeddedIMU name=\"imu 1\" port=\"0\" bus=\"0\" />\r\n        </LynxModule>\r\n    </LynxUsbDevice>\r\n</Robot>\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/cfg_files/Craig 1.xml	(revision a6e8d7abddb208c5e6740b3da665368e8ce3bf8a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/opmodes/cfg_files/Craig 1.xml	(date 1582499009788)
@@ -9,7 +9,7 @@
             <Servo name="clamp_servo" port="0" />
             <Servo name="right_intake" port="1" />
             <Servo name="gripper_servo" port="2" />
-            <Servo name="left_intake" port="3" />
+            <Servo name="led_one" port="3" />
             <Servo name="conveyor_belt" port="4" />
             <Servo name="arm_servo" port="5" />
             <LynxEmbeddedIMU name="imu" port="0" bus="0" />
@@ -25,6 +25,7 @@
             <Servo name="back_dragger_servo" port="4" />
             <Servo name="front_dragger_servo" port="5" />
             <LynxEmbeddedIMU name="imu 1" port="0" bus="0" />
+            <LynxColorSensor name="Color_Sensor" port="0" bus="1" />
         </LynxModule>
     </LynxUsbDevice>
 </Robot>
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/hardware/devices/drive/Drive.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.mecanum.hardware.devices.drive;\r\n\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.DcMotorSimple;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\nimport com.qualcomm.robotcore.hardware.MotorControlAlgorithm;\r\nimport com.qualcomm.robotcore.hardware.PIDFCoefficients;\r\n\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.DoubleTelemetry;\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.PIDController;\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.inputs.sensors.IMU;\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.outputs.SlewDcMotor;\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.purepursuit.MecanumPurePursuitController;\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.purepursuit.Pose;\r\nimport org.firstinspires.ftc.teamcode.mecanum.hardware.Robot;\r\nimport org.firstinspires.ftc.teamcode.mecanum.hardware.RobotState;\r\nimport org.upacreekrobotics.dashboard.Config;\r\n\r\nimport static org.firstinspires.ftc.teamcode.mecanum.hardware.Constants.*;\r\n\r\n@Config\r\npublic class Drive extends MecanumPurePursuitController {\r\n\r\n    private IMU imu;\r\n    private double lastLeftPosition = 0, lastRightPosition = 0;\r\n    private double strafeOffset = 0.0, straightOffset = 0.0;\r\n    public static double p=16,i=0,d=0,f=12;\r\n\r\n    private SlewDcMotor dcMotorFrontLeft;\r\n    private SlewDcMotor dcMotorFrontRight;\r\n    private SlewDcMotor dcMotorBackLeft;\r\n    private SlewDcMotor dcMotorBackRight;\r\n    private SlewDcMotor straightEncoder,strafeEncoder;\r\n\r\n    public Drive(HardwareMap hardwareMap, DoubleTelemetry telemetry) {\r\n        //super(20, 1.4, new PIDController(50, 0, 100), telemetry);\r\n        super(20, 1.4, new PIDController(20, 0, 10), telemetry);\r\n\r\n        imu = new IMU(hardwareMap);\r\n        //imu = hardwareMap.getImu(\"imu\");\r\n\r\n        dcMotorFrontLeft = new SlewDcMotor((hardwareMap.dcMotor.get(\"front_left\")));\r\n        dcMotorFrontRight = new SlewDcMotor((hardwareMap.dcMotor.get(\"front_right\")));\r\n        dcMotorBackLeft = new SlewDcMotor((hardwareMap.dcMotor.get(\"back_left\")));\r\n        dcMotorBackRight = new SlewDcMotor((hardwareMap.dcMotor.get(\"back_right\")));\r\n\r\n        straightEncoder = new SlewDcMotor(hardwareMap.dcMotor.get(\"straight_encoder\"));\r\n        strafeEncoder = new SlewDcMotor(hardwareMap.dcMotor.get(\"strafe_encoder\"));\r\n\r\n        dcMotorFrontLeft.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        dcMotorBackLeft.setDirection(DcMotorSimple.Direction.REVERSE);\r\n        dcMotorFrontRight.setDirection(DcMotorSimple.Direction.FORWARD);\r\n        dcMotorBackRight.setDirection(DcMotorSimple.Direction.FORWARD);\r\n\r\n        dcMotorFrontLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        dcMotorFrontRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        dcMotorBackLeft.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n        dcMotorBackRight.setZeroPowerBehavior(DcMotor.ZeroPowerBehavior.BRAKE);\r\n\r\n        setSlewRate(2.0);  //Increase slew rate from default 0.1 to 2.0 speed change in 15 ms\r\n\r\n        setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        resetPosition();\r\n\r\n        setMode(RobotState.MatchState.AUTONOMOUS == RobotState.currentMatchState ? DcMotor.RunMode.RUN_USING_ENCODER : DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n\r\n        setVelocityPIDCoefficients(new PIDFCoefficients(p,i,d,f));\r\n    }\r\n\r\n    public void setLeftMotorIntakePower(double power){\r\n        straightEncoder.setPower(power);\r\n    }\r\n\r\n    public void setRightMotorIntakePower(double power){\r\n        strafeEncoder.setPower(-power);\r\n    }\r\n\r\n    public void setDrivePowerAll(double FL, double FR, double BL, double BR) {\r\n        dcMotorFrontLeft.setPower(FL);\r\n        dcMotorFrontRight.setPower(FR);\r\n        dcMotorBackLeft.setPower(BL);\r\n        dcMotorBackRight.setPower(BR);\r\n        //telemetry.addData(DoubleTelemetry.LogMode.INFO, dcMotorFrontLeft.getCurrentPosition(), dcMotorFrontRight.getCurrentPosition());\r\n    }\r\n\r\n    public void resetAngleToZero() {\r\n        imu.resetAngleToZero();\r\n    }\r\n\r\n    public Pose getCurrentPosition(){\r\n        return currentPosition;\r\n    }\r\n\r\n\r\n    @Override\r\n    public double getActualHeadingDegrees() {\r\n        return imu.getHeading();\r\n    }\r\n\r\n    @Override\r\n    public double getXActualPositionInches() {\r\n        return getStraightPosition();\r\n    }\r\n\r\n    @Override\r\n    public double getYActualPositionInches() {\r\n        return getStrafePosition();\r\n    }\r\n\r\n    public void setHeadingMode(HeadingMode headingMode){\r\n        super.setHeadingMode(headingMode);\r\n    }\r\n\r\n    public int getFrontLeftPosition() {\r\n        return dcMotorFrontLeft.getCurrentPosition();\r\n    }\r\n\r\n    public int getFrontRightPosition() {\r\n        //Negative for the odometry wheels\r\n        return dcMotorFrontRight.getCurrentPosition();\r\n    }\r\n\r\n    public  int getBackLeftPosition(){\r\n        return dcMotorBackLeft.getCurrentPosition();\r\n    }\r\n\r\n    public  int getBackRightPosition() {\r\n        return dcMotorBackRight.getCurrentPosition();\r\n    }\r\n\r\n    public  double getStraightPosition(){\r\n\r\n        return (((double)(-straightEncoder.getCurrentPosition())/STRAIGHT_ENCODER_COUNTS_INCH));\r\n    }\r\n\r\n    public  double getStrafePosition(){\r\n        return (((double)(strafeEncoder.getCurrentPosition()))/STRAFE_ENCODER_COUNTS_INCH);\r\n    }\r\n\r\n    @Override\r\n    public void setMecanumPower(double fl, double fr, double bl, double br) {\r\n        setDrivePowerAll(fl, fr, bl, br);\r\n    }\r\n\r\n    public void setMode(DcMotor.RunMode mode) {\r\n        if (mode == DcMotor.RunMode.STOP_AND_RESET_ENCODER) encodersZero();\r\n        dcMotorFrontLeft.setMode(mode);\r\n        dcMotorBackLeft.setMode(mode);\r\n        dcMotorFrontRight.setMode(mode);\r\n        dcMotorBackRight.setMode(mode);\r\n        strafeEncoder.setMode(mode);\r\n        straightEncoder.setMode(mode);\r\n    }\r\n\r\n    public void setVelocityPIDCoefficients(PIDFCoefficients pidfCoefficients){\r\n        dcMotorFrontLeft.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER,pidfCoefficients);\r\n        dcMotorBackLeft.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER,pidfCoefficients);\r\n        dcMotorFrontRight.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER,pidfCoefficients);\r\n        dcMotorBackRight.setPIDFCoefficients(DcMotor.RunMode.RUN_USING_ENCODER,pidfCoefficients);\r\n        }\r\n\r\n    public void resetEncoders(){\r\n        setMode(DcMotor.RunMode.STOP_AND_RESET_ENCODER);\r\n        setMode(DcMotor.RunMode.RUN_USING_ENCODER);\r\n    }\r\n\r\n    public void encodersZero() {\r\n        lastLeftPosition = 0;\r\n        lastRightPosition = 0;\r\n        straightOffset = 0;\r\n        straightOffset = getStraightPosition();\r\n        strafeOffset = 0;\r\n        strafeOffset = getStrafePosition();\r\n    }\r\n\r\n    public void setSlewRate(double slewSpeed){\r\n        dcMotorBackLeft.setSlewSpeed(slewSpeed);\r\n        dcMotorBackRight.setSlewSpeed(slewSpeed);\r\n        dcMotorFrontLeft.setSlewSpeed(slewSpeed);\r\n        dcMotorFrontRight.setSlewSpeed(slewSpeed);\r\n    }\r\n\r\n    public double getHeading() {\r\n        return imu.getHeading();\r\n    }\r\n\r\n    public void stop() {\r\n        setDrivePowerAll(0, 0, 0, 0);\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/hardware/devices/drive/Drive.java	(revision a6e8d7abddb208c5e6740b3da665368e8ce3bf8a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/hardware/devices/drive/Drive.java	(date 1582500570466)
@@ -34,7 +34,7 @@
 
     public Drive(HardwareMap hardwareMap, DoubleTelemetry telemetry) {
         //super(20, 1.4, new PIDController(50, 0, 100), telemetry);
-        super(20, 1.4, new PIDController(20, 0, 10), telemetry);
+        super(20, 1.4, new PIDController(15, 0, 10), telemetry);
 
         imu = new IMU(hardwareMap);
         //imu = hardwareMap.getImu("imu");
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/hardware/AutonPursuitPaths.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode.mecanum.hardware;\r\n\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.paths.Path;\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.paths.PurePursuitSegment;\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.purepursuit.Point;\r\nimport org.firstinspires.ftc.teamcode.framework.userhardware.purepursuit.PursuitPath;\r\n\r\npublic class AutonPursuitPaths {\r\n\r\n    /*  This class countains all the paths for the pure pursuit-based stone collections */\r\n    /*  The stones are numbered from the wall from 1 to 6 */\r\n    /*  The origin point (0,0) is the robot's starting position */\r\n    /*  Every point is referenced absolutely to this reference frame - no relative distances */\r\n    public static double RED_PARK_X = 8.0;\r\n    public static double RED_PARK_Y = 0.5;\r\n\r\n    public static double BLUE_PARK_X = 8.0;\r\n    public static double BLUE_PARK_Y = -0.5;\r\n\r\n    public static double FIELD_OFFSET = -0.75;\r\n    public static int PERIOD = 200;\r\n\r\n\r\n    public static double RED_BLOCK_LOCATION_Y = -25.5 + FIELD_OFFSET;\r\n    public static double RED_FOUNDATION_Y = -29.0;\r\n    public static double RED_FOUNDATION_Y_2ND = -32.5;\r\n\r\n    public static double RED_FOUNDATION_NEAR_X = -74;  //  Play with this parameter\r\n    public static double RED_FOUNDATION_MIDDLE_NEAR_X = -77;  //  Play with this parameter\r\n    public static double RED_FOUNDATION_MIDDLE_X = -86;  //Measure this parameter\r\n\r\n    // public static double RED_FOUNDATION_DRAGGER_X = -75;\r\n    public static double RED_RUNWAY_Y = -19;  //  Play with this parameter\r\n    public static double RED_RUNWAY_Y_2 = -19.5;\r\n    public static double RED_DRAGGER_BACKUP_Y = -23;\r\n    public static double RED_DRAGGER_FORWARD_HALFWAY_Y = -26;\r\n    public static double RED_DRAGGER_FORWARD_FULL_Y = -29;\r\n    public static double OFF_SET = 0;\r\n    //count from wall\r\n    public static double RED_BLOCK1_X = 30;\r\n    public static double RED_BLOCK2_X = 23;\r\n    public static double RED_BLOCK3_X = 14;//Was 16\r\n    public static double RED_BLOCK4_X = 6;\r\n    public static double RED_BLOCK5_X = -2;\r\n    public static double RED_BLOCK6_X = -10;\r\n\r\n    public static double BLUE_RUNWAY_Y = -19;\r\n    public static double BLUE_RUNWAY_Y_2 = -19.5;\r\n\r\n    public static double BLUE_FOUNDATION_Y = -31;\r\n    public static double BLUE_FOUNDATION_Y_2ND = -34.5;\r\n    public static double BLUE_FOUNDATION_MIDDLE_X = 88;\r\n    public static double BLUE_FOUNDATION_MIDDLE_NEAR_X = 78;\r\n    public static double BLUE_FOUNDATION_NEAR_X = 72.5;\r\n    public static double BLUE_BLOCK_LOCATION_Y = -26.5 + FIELD_OFFSET;\r\n    //count from wall\r\n    public static double BLUE_BLOCK1_X = -30;\r\n    public static double BLUE_BLOCK2_X = -23;\r\n    public static double BLUE_BLOCK3_X = -15;\r\n    public static double BLUE_BLOCK4_X = -7;\r\n    public static double BLUE_BLOCK5_X = 1;\r\n    public static double BLUE_BLOCK6_X = 7;\r\n\r\n\r\n    /*  Paths for red side left sky stone*/\r\n\r\n    public final static Path RedPurePursuitLeft = new Path(\"collect left sky stones\");\r\n\r\n    static {\r\n        RedPurePursuitLeft.addSegment(new PurePursuitSegment(\"drive to first sky stone\",\r\n                new PursuitPath(\r\n                        new Point(0, 0),\r\n                        new Point(RED_BLOCK4_X, RED_BLOCK_LOCATION_Y))\r\n                        .setMaxAcceleration(0.01), 0));\r\n        RedPurePursuitLeft.addSegment(new PurePursuitSegment(\"first trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK4_X, RED_BLOCK_LOCATION_Y),\r\n                        new Point(RED_BLOCK4_X, RED_RUNWAY_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_RUNWAY_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_FOUNDATION_Y)), PERIOD));\r\n        RedPurePursuitLeft.addSegment(new PurePursuitSegment(\"drive to second sky stone\",\r\n                new PursuitPath(\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_FOUNDATION_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_RUNWAY_Y),\r\n                        new Point(RED_BLOCK1_X + 1, RED_RUNWAY_Y + OFF_SET),\r\n                        new Point(RED_BLOCK1_X + 1, RED_BLOCK_LOCATION_Y - 2)).setMaxDeceleration(0.01), PERIOD));\r\n        RedPurePursuitLeft.addSegment(new PurePursuitSegment(\"second trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK1_X + 1, RED_BLOCK_LOCATION_Y - 2),\r\n                        new Point(RED_BLOCK1_X + 1, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_FOUNDATION_Y)), PERIOD));\r\n        RedPurePursuitLeft.addSegment(new PurePursuitSegment(\"drive to third sky stone\",\r\n                new PursuitPath(\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_FOUNDATION_Y),\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_BLOCK6_X + 2, RED_RUNWAY_Y_2),\r\n                        new Point(RED_BLOCK6_X + 2, RED_BLOCK_LOCATION_Y - 2)).setMaxDeceleration(0.013), PERIOD));\r\n        RedPurePursuitLeft.addSegment(new PurePursuitSegment(\"last trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK6_X + 2, RED_BLOCK_LOCATION_Y - 2),\r\n                        new Point(RED_BLOCK6_X + 2, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_FOUNDATION_Y_2ND))\r\n                        .setMaxDeceleration(0.01)\r\n                        .setPointSpacing(1.0)\r\n                        .setPathSmoothing(0.5), PERIOD));\r\n\r\n    }\r\n\r\n    public final static Path RedPurePursuitCenterTest = new Path(\"collect center sky stones\");\r\n\r\n    static {\r\n        RedPurePursuitCenterTest.addSegment(new PurePursuitSegment(\"drive to first sky stone\",\r\n                new PursuitPath(\r\n                        new Point(0, 0),\r\n                        new Point(RED_BLOCK5_X, RED_BLOCK_LOCATION_Y))\r\n                        .setMaxAcceleration(0.01), 0));\r\n    }\r\n\r\n    public final static Path RedPurePursuitCenter = new Path(\"collect center sky stones\");\r\n\r\n    static {\r\n        RedPurePursuitCenter.addSegment(new PurePursuitSegment(\"drive to first sky stone\",\r\n                new PursuitPath(\r\n                        new Point(0, 0),\r\n                        new Point(RED_BLOCK5_X, RED_BLOCK_LOCATION_Y))\r\n                        .setMaxAcceleration(0.01), 0));\r\n        RedPurePursuitCenter.addSegment(new PurePursuitSegment(\"first trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK5_X, RED_BLOCK_LOCATION_Y),\r\n                        new Point(RED_BLOCK5_X, RED_RUNWAY_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_RUNWAY_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_FOUNDATION_Y)), PERIOD + 50));\r\n        RedPurePursuitCenter.addSegment(new PurePursuitSegment(\"drive to second sky stone\",\r\n                new PursuitPath(\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_FOUNDATION_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_RUNWAY_Y),\r\n                        new Point(RED_BLOCK2_X, RED_RUNWAY_Y),\r\n                        new Point(RED_BLOCK2_X, RED_BLOCK_LOCATION_Y + OFF_SET - 2)).setMaxDeceleration(0.013), PERIOD));\r\n        RedPurePursuitCenter.addSegment(new PurePursuitSegment(\"second trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK2_X, RED_BLOCK_LOCATION_Y + OFF_SET - 2),\r\n                        new Point(RED_BLOCK2_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_FOUNDATION_Y)), PERIOD));\r\n        RedPurePursuitCenter.addSegment(new PurePursuitSegment(\"drive to third sky stone\",\r\n                new PursuitPath(\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_FOUNDATION_Y),\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_BLOCK6_X + 2, RED_RUNWAY_Y_2),\r\n                        new Point(RED_BLOCK6_X + 2, RED_BLOCK_LOCATION_Y - 2))\r\n                        .setMaxDeceleration(0.01), PERIOD));\r\n        RedPurePursuitCenter.addSegment(new PurePursuitSegment(\"last trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK6_X + 2, RED_BLOCK_LOCATION_Y - 2),\r\n                        new Point(RED_BLOCK6_X + 2, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_FOUNDATION_Y_2ND))\r\n                        .setMaxDeceleration(0.01)\r\n                        .setPointSpacing(1.0)\r\n                        .setPathSmoothing(0.5), PERIOD));\r\n    }\r\n\r\n    public final static Path RedPurePursuitCenterMoreStone = new Path(\"collect center sky stones\");\r\n\r\n    static {\r\n        RedPurePursuitCenterMoreStone.addSegment(new PurePursuitSegment(\"drive to first sky stone\",\r\n                new PursuitPath(\r\n                        new Point(0, 0),\r\n                        new Point(RED_BLOCK5_X, RED_BLOCK_LOCATION_Y))\r\n                        .setMaxAcceleration(0.01), 0));\r\n        RedPurePursuitCenterMoreStone.addSegment(new PurePursuitSegment(\"first trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK5_X, RED_BLOCK_LOCATION_Y),\r\n                        new Point(RED_BLOCK5_X, RED_RUNWAY_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_RUNWAY_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_FOUNDATION_Y)), 0));\r\n        RedPurePursuitCenterMoreStone.addSegment(new PurePursuitSegment(\"drive to second sky stone\",\r\n                new PursuitPath(\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_FOUNDATION_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_RUNWAY_Y),\r\n                        new Point(RED_BLOCK2_X, RED_RUNWAY_Y),\r\n                        new Point(RED_BLOCK2_X, RED_BLOCK_LOCATION_Y + OFF_SET)), 0));\r\n        RedPurePursuitCenterMoreStone.addSegment(new PurePursuitSegment(\"second trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK2_X, RED_BLOCK_LOCATION_Y + OFF_SET),\r\n                        new Point(RED_BLOCK2_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_FOUNDATION_Y)), 50));\r\n        RedPurePursuitCenterMoreStone.addSegment(new PurePursuitSegment(\"drive to third sky stone\",\r\n                new PursuitPath(\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_FOUNDATION_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_BLOCK6_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_BLOCK6_X, RED_BLOCK_LOCATION_Y))\r\n                        .setMaxDeceleration(0.01), 100));\r\n        RedPurePursuitCenterMoreStone.addSegment(new PurePursuitSegment(\"last trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK6_X, RED_BLOCK_LOCATION_Y),\r\n                        new Point(RED_BLOCK6_X + 10, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_FOUNDATION_Y_2ND)), 100));\r\n//        RedPurePursuitCenterMoreStone.addSegment(new PurePursuitSegment(\"drive to fourth sky stone\",\r\n//                new PursuitPath(new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_FOUNDATION_Y_2ND), new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_RUNWAY_Y_2), new Point(RED_BLOCK4_X, RED_RUNWAY_Y_2), new Point(RED_BLOCK4_X, RED_BLOCK_LOCATION_Y)), 100));\r\n//        RedPurePursuitCenterMoreStone.addSegment(new PurePursuitSegment(\"fourth trip to foundation\",\r\n//                new PursuitPath(new Point(RED_BLOCK4_X, RED_BLOCK_LOCATION_Y), new Point(RED_BLOCK4_X, RED_RUNWAY_Y_2), new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_RUNWAY_Y_2), new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_FOUNDATION_Y_2ND)), 100));\r\n    }\r\n\r\n    public final static Path RedPurePursuitRight = new Path(\"collect right sky stones\");\r\n\r\n    static {\r\n        RedPurePursuitRight.addSegment(new PurePursuitSegment(\"drive to first sky stone\",\r\n                new PursuitPath(\r\n                        new Point(0, 0),\r\n                        new Point(RED_BLOCK6_X - 1, RED_BLOCK_LOCATION_Y))\r\n                        .setMaxAcceleration(0.01), 0));\r\n        RedPurePursuitRight.addSegment(new PurePursuitSegment(\"first trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK6_X, RED_BLOCK_LOCATION_Y),\r\n                        new Point(RED_BLOCK6_X, RED_RUNWAY_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_RUNWAY_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_FOUNDATION_Y)), PERIOD));\r\n        RedPurePursuitRight.addSegment(new PurePursuitSegment(\"drive to second sky stone\",\r\n                new PursuitPath(\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_FOUNDATION_Y),\r\n                        new Point(RED_FOUNDATION_MIDDLE_X, RED_RUNWAY_Y),\r\n                        new Point(RED_BLOCK3_X, RED_RUNWAY_Y),\r\n                        new Point(RED_BLOCK3_X, RED_BLOCK_LOCATION_Y + OFF_SET - 2))\r\n                        .setMaxDeceleration(0.013), PERIOD));\r\n        RedPurePursuitRight.addSegment(new PurePursuitSegment(\"second trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK3_X, RED_BLOCK_LOCATION_Y - 2),\r\n                        new Point(RED_BLOCK3_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_FOUNDATION_Y)), PERIOD));\r\n        RedPurePursuitRight.addSegment(new PurePursuitSegment(\"drive to third sky stone\",\r\n                new PursuitPath(\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_FOUNDATION_Y),\r\n                        new Point(RED_FOUNDATION_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_BLOCK5_X + 2, RED_RUNWAY_Y_2),\r\n                        new Point(RED_BLOCK5_X + 2, RED_BLOCK_LOCATION_Y - 2))\r\n                        .setMaxDeceleration(0.01), PERIOD));\r\n        RedPurePursuitRight.addSegment(new PurePursuitSegment(\"last trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(RED_BLOCK5_X + 2, RED_BLOCK_LOCATION_Y - 2),\r\n                        new Point(RED_BLOCK5_X + 2, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_RUNWAY_Y_2),\r\n                        new Point(RED_FOUNDATION_MIDDLE_NEAR_X, RED_FOUNDATION_Y_2ND))\r\n                        .setMaxDeceleration(0.01)\r\n                        .setPointSpacing(1.0)\r\n                        .setPathSmoothing(0.5), PERIOD));\r\n    }\r\n\r\n    public final static Path RedDragFoundation = new Path(\"Red Drag Foundation\");\r\n\r\n    static {\r\n        RedDragFoundation.addSegment(new PurePursuitSegment(\"Pull the foundation\", new PursuitPath(\r\n                new Point(RED_FOUNDATION_MIDDLE_NEAR_X + 0, RED_FOUNDATION_Y_2ND + 0),\r\n                new Point(RED_FOUNDATION_MIDDLE_NEAR_X + 20, RED_FOUNDATION_Y_2ND + 16))\r\n                .setMinSpeed(0.8)\r\n                .setTurnSpeed(1.0)\r\n                .setTurnGain(1.0)\r\n                .setPositionError(15.0)\r\n                .setHeadingError(10.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 1000, -55, 1600));\r\n        RedDragFoundation.addSegment(new PurePursuitSegment(\"park the foundation\", new PursuitPath(\r\n                new Point(RED_FOUNDATION_MIDDLE_NEAR_X + 20, RED_FOUNDATION_Y_2ND + 14),\r\n                new Point(RED_FOUNDATION_MIDDLE_NEAR_X + 6, RED_FOUNDATION_Y_2ND + 8))\r\n                .setMinSpeed(1.1)\r\n                .setTurnSpeed(1.0)\r\n                .setTurnGain(3.0)\r\n                .setPositionError(15.0)\r\n                .setHeadingError(10.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0, -90, 1500));\r\n        RedDragFoundation.addSegment(new PurePursuitSegment(\"park the robot\", new PursuitPath(\r\n                new Point(RED_FOUNDATION_MIDDLE_NEAR_X + 14, RED_FOUNDATION_Y_2ND + 5),\r\n                new Point(RED_FOUNDATION_MIDDLE_NEAR_X + 18, RED_FOUNDATION_Y_2ND + 3),\r\n                new Point(RED_FOUNDATION_MIDDLE_NEAR_X + 52, RED_FOUNDATION_Y_2ND + 1))\r\n                .setMinSpeed(0.25)\r\n                .setMaxSpeed(0.6)\r\n                .setTurnSpeed(0.1)\r\n                .setTurnGain(1.0)\r\n                .setPositionError(6.0)\r\n                .setHeadingError(8.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0, -90, 3000));\r\n\r\n    }\r\n\r\n    public final static Path RedDragFoundationTest = new Path(\"Red Drag Foundation Test\");\r\n\r\n    static {\r\n        RedDragFoundationTest.addSegment(new PurePursuitSegment(\"Pull the foundation\", new PursuitPath(\r\n                new Point(0, 0),\r\n                new Point(20, +16))\r\n                .setMinSpeed(0.7)\r\n                .setTurnSpeed(1.0)\r\n                .setTurnGain(1.0)\r\n                .setPositionError(15.0)\r\n                .setHeadingError(10.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 500, -55, 1500));\r\n        RedDragFoundationTest.addSegment(new PurePursuitSegment(\"park the foundation\", new PursuitPath(\r\n                new Point(20, +14),\r\n                new Point(6, +8))\r\n                .setMinSpeed(0.8)\r\n                .setTurnSpeed(1.0)\r\n                .setTurnGain(2.0)\r\n                .setPositionError(15.0)\r\n                .setHeadingError(10.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0, -90, 1300));\r\n        RedDragFoundationTest.addSegment(new PurePursuitSegment(\"park the robot\", new PursuitPath(\r\n                new Point(14, +5),\r\n                new Point(18, 3),\r\n                new Point(52, 3))\r\n                .setMinSpeed(0.25)\r\n                .setMaxSpeed(0.6)\r\n                .setTurnSpeed(0.1)\r\n                .setTurnGain(1.0)\r\n                .setPositionError(6.0)\r\n                .setHeadingError(8.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0, -90, 3000));\r\n\r\n//        BlueDragFoundationTest.addSegment(new PurePursuitSegment(\"park the foundation\", new PursuitPath(new Point(-20, +12), new Point(-17, +4)).setMinSpeed(0.3).setPositionError(4.0), 0, 90));\r\n//        BlueDragFoundationTest.addSegment(new PurePursuitSegment(\"park the robot\", new PursuitPath(new Point(- -17, +4), new Point(-26, +1), new Point(-48, +-2)).setMinSpeed(0.3).setPositionError(4.0), 0, 90));\r\n    }\r\n\r\n    public final static Path RedDragFoundationPark = new Path(\"Red Drag Foundation Park\");\r\n\r\n    static {\r\n        RedDragFoundationPark.addSegment(new PurePursuitSegment(\"drive to the wall\", new PursuitPath(\r\n                new Point(RED_FOUNDATION_MIDDLE_X, RED_RUNWAY_Y_2),\r\n                new Point(RED_FOUNDATION_MIDDLE_X + 6, RED_RUNWAY_Y_2 + 4))\r\n                .setMinSpeed(0.8)\r\n                .setPositionError(10.0), PERIOD));\r\n//        RedDragFoundationPark.addSegment(new PurePursuitSegment(\"park the foundation\", new PursuitPath(\r\n//                new Point(RED_FOUNDATION_MIDDLE_X, RED_RUNWAY_Y_2 + 8),\r\n//                new Point(RED_FOUNDATION_MIDDLE_X - 10, RED_RUNWAY_Y_2 + 8))\r\n//                .setMinSpeed(0.5)\r\n//                .setPositionError(4.0)\r\n//                .setHeadingError(15.0)\r\n//                .setTurnSpeed(1.0), PERIOD, -90));\r\n\r\n//        RedDragFoundationPark.addSegment(new PurePursuitSegment(\"park the robot\", new PursuitPath(\r\n//                new Point(RED_FOUNDATION_MIDDLE_X - 16, RED_RUNWAY_Y_2 + 12),\r\n//                new Point(RED_FOUNDATION_MIDDLE_X - 16, RED_RUNWAY_Y_2),\r\n//                new Point(RED_FOUNDATION_MIDDLE_X + 16, RED_RUNWAY_Y_2))\r\n//                .setMinSpeed(0.3)\r\n//                .setPositionError(4.0), PERIOD, -90));\r\n\r\n    }\r\n\r\n    public final static Path RedRobotPark = new Path(\"Red Robot Park\");\r\n\r\n    static {\r\n\r\n        RedRobotPark.addSegment(new PurePursuitSegment(\"park the robot\", new PursuitPath(\r\n                new Point(RED_FOUNDATION_MIDDLE_X + 10, -45),\r\n                new Point(-49, -44))\r\n                .setMinSpeed(0.3)\r\n                .setHeadingError(10.0)\r\n                .setPositionError(3.0), PERIOD, -90));\r\n    }\r\n\r\n    public final static Path CalibrationPath = new Path(\"Calibration Path\");\r\n\r\n    static {\r\n\r\n        CalibrationPath.addSegment(new PurePursuitSegment(\"first trip to foundation\", new PursuitPath(\r\n                new Point(0, 0),\r\n                new Point(0, 10),\r\n                new Point(80, 10),\r\n                new Point(80, 0))));\r\n        CalibrationPath.addSegment(new PurePursuitSegment(\"drive back\", new PursuitPath(\r\n                new Point(80, 0),\r\n                new Point(80, 10),\r\n                new Point(0, 10),\r\n                new Point(0, 0))));\r\n\r\n    }\r\n\r\n    public final static Path lastStoneDrive = new Path(\"last stone drive\");\r\n\r\n    static {\r\n        lastStoneDrive.addSegment(new PurePursuitSegment(\"trip to last stone\", new PursuitPath(\r\n                new Point(0, 0),\r\n                new Point(48, 0))));\r\n    }\r\n\r\n    public final static Path middleLastStone = new Path(\"middle last stone delivery\");\r\n\r\n    static {\r\n        middleLastStone.addSegment(new PurePursuitSegment(\"drive to last stone\", new PursuitPath(\r\n                new Point(48, 0),\r\n                new Point(48, RED_BLOCK_LOCATION_Y))));\r\n        middleLastStone.addSegment(new PurePursuitSegment(\"drive to foundation\", new PursuitPath(new Point(48, RED_BLOCK_LOCATION_Y), new Point(48, RED_RUNWAY_Y_2), new Point(-72, RED_RUNWAY_Y_2))));\r\n    }\r\n\r\n    public final static Path RedDragFoundationParking = new Path(\"Red Drag Foundation parking\");\r\n\r\n    static {\r\n        RedDragFoundationParking.addSegment(new PurePursuitSegment(\"drive down the wall\", new PursuitPath(new Point(0, 0), new Point(-12, 0)), 0));\r\n        RedDragFoundationParking.addSegment(new PurePursuitSegment(\"drive up to the foundation\", new PursuitPath(new Point(-12, 0), new Point(-12, RED_FOUNDATION_Y_2ND)), 0));\r\n        RedDragFoundationParking.addSegment(new PurePursuitSegment(\"Pull the foundation\", new PursuitPath(new Point(0 - 12, 0 + RED_FOUNDATION_Y_2ND), new Point(20 - 12, 12 + RED_FOUNDATION_Y_2ND)).setMinSpeed(0.6).setPositionError(5.0), 0, -35));\r\n        RedDragFoundationParking.addSegment(new PurePursuitSegment(\"park the foundation\", new PursuitPath(new Point(20 - 12, 12 + RED_FOUNDATION_Y_2ND), new Point(20 - 12, 6 + RED_FOUNDATION_Y_2ND)).setMinSpeed(0.4).setPositionError(5.0), 0, -90));\r\n        RedDragFoundationParking.addSegment(new PurePursuitSegment(\"park the robot\", new PursuitPath(new Point(24 - 12, 4 + RED_FOUNDATION_Y_2ND), new Point(26 - 12, 3 + RED_FOUNDATION_Y_2ND), new Point(55 - 12, 6)).setMinSpeed(0.3).setPositionError(4.0), 0, -90));\r\n    }\r\n\r\n    public final static Path RedDragFoundationParking2 = new Path(\"Red Drag Foundation parking 2\");\r\n\r\n    static {\r\n        RedDragFoundationParking2.addSegment(new PurePursuitSegment(\"drive down the wall\", new PursuitPath(\r\n                new Point(0, 0),\r\n                new Point(-22, 0))\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0));\r\n        RedDragFoundationParking2.addSegment(new PurePursuitSegment(\"drive up to the foundation\", new PursuitPath(\r\n                new Point(-22, 0),\r\n                new Point(-22, RED_FOUNDATION_Y_2ND)).setPathSmoothing(0.5).setPointSpacing(1.0), 0));\r\n        RedDragFoundationParking2.addSegment(new PurePursuitSegment(\"Pull the foundation\", new PursuitPath(\r\n                new Point(-22, RED_FOUNDATION_Y_2ND),\r\n                new Point(-3, -10))\r\n                .setMinSpeed(0.6)\r\n                .setPositionError(5.0)\r\n                .setTurnSpeed(0.6)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 1000, -35));\r\n        RedDragFoundationParking2.addSegment(new PurePursuitSegment(\"park the foundation\", new PursuitPath(\r\n                new Point(-3, -10),\r\n                new Point(2, -4))\r\n                .setMinSpeed(0.5)\r\n                .setPositionError(8.0)\r\n                .setTurnSpeed(0.7)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0, -90));\r\n        RedDragFoundationParking2.addSegment(new PurePursuitSegment(\"park the robot\", new PursuitPath(\r\n                new Point(2, -4),\r\n                new Point(1, -3),\r\n                new Point(55 - 12, -1))\r\n                .setMinSpeed(0.3)\r\n                .setPositionError(4.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0, -90));\r\n    }\r\n\r\n    public final static Path RunwayDrive = new Path(\"Drive along runway\");\r\n\r\n    static {\r\n        RunwayDrive.addSegment(new PurePursuitSegment(\"Run along runway\", new PursuitPath(new Point(0, 0), new Point(-50, 0))));\r\n        RunwayDrive.addSegment(new PurePursuitSegment(\"Run along runway 2\", new PursuitPath(new Point(-50, 0), new Point(-100, 0)), 1000));\r\n    }\r\n\r\n    public final static Path BluePurePursuitLeft = new Path(\"collect left sky stones on blue side\");\r\n\r\n    static {\r\n        BluePurePursuitLeft.addSegment(new PurePursuitSegment(\"drive to first sky stone\",\r\n                new PursuitPath(new Point(0, 0), new Point(BLUE_BLOCK6_X, BLUE_BLOCK_LOCATION_Y + 1)).setMaxAcceleration(0.01).setMaxDeceleration(0.015), 0));\r\n        BluePurePursuitLeft.addSegment(new PurePursuitSegment(\"first trip to foundation\",\r\n                new PursuitPath(new Point(BLUE_BLOCK6_X, BLUE_BLOCK_LOCATION_Y),\r\n                        new Point(BLUE_BLOCK6_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_FOUNDATION_Y + 1))\r\n                        .setMaxDeceleration(0.015), PERIOD));\r\n        BluePurePursuitLeft.addSegment(new PurePursuitSegment(\"drive to second sky stone\",\r\n                new PursuitPath(new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_FOUNDATION_Y + 1),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_BLOCK3_X, BLUE_RUNWAY_Y + OFF_SET),\r\n                        new Point(BLUE_BLOCK3_X, BLUE_BLOCK_LOCATION_Y - 1)).setMaxDeceleration(0.015), PERIOD));\r\n        BluePurePursuitLeft.addSegment(new PurePursuitSegment(\"second trip to foundation\",\r\n                new PursuitPath(new Point(BLUE_BLOCK3_X, BLUE_BLOCK_LOCATION_Y - 1),\r\n                        new Point(BLUE_BLOCK3_X, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_NEAR_X, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_NEAR_X + 5, BLUE_FOUNDATION_Y)), PERIOD));\r\n        BluePurePursuitLeft.addSegment(new PurePursuitSegment(\"drive to third sky stone\",\r\n                new PursuitPath(new Point(BLUE_FOUNDATION_NEAR_X + 5, BLUE_FOUNDATION_Y),\r\n                        new Point(BLUE_FOUNDATION_NEAR_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_BLOCK5_X + 2, BLUE_RUNWAY_Y + OFF_SET),\r\n                        new Point(BLUE_BLOCK5_X + 2, BLUE_BLOCK_LOCATION_Y - 1)).setMaxDeceleration(0.013), PERIOD));\r\n        BluePurePursuitLeft.addSegment(new PurePursuitSegment(\"last trip to foundation\",\r\n                new PursuitPath(new Point(BLUE_BLOCK5_X + 2, BLUE_BLOCK_LOCATION_Y - 1),\r\n                        new Point(BLUE_BLOCK5_X + 2, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X, BLUE_FOUNDATION_Y_2ND))\r\n                        .setMaxDeceleration(0.01)\r\n                        .setPointSpacing(1.0)\r\n                        .setPathSmoothing(0.5), PERIOD));\r\n\r\n    }\r\n\r\n    public final static Path BluePurePursuitCenter = new Path(\"collect center sky stones on blue side\");\r\n\r\n    static {\r\n        BluePurePursuitCenter.addSegment(new PurePursuitSegment(\"drive to first sky stone\",\r\n                new PursuitPath(\r\n                        new Point(0, 0),\r\n                        new Point(BLUE_BLOCK5_X, BLUE_BLOCK_LOCATION_Y + 1))\r\n                        .setMaxAcceleration(0.01).setMaxDeceleration(0.015), 0));\r\n        BluePurePursuitCenter.addSegment(new PurePursuitSegment(\"first trip to foundation\",\r\n                new PursuitPath(\r\n                        new Point(BLUE_BLOCK5_X, BLUE_BLOCK_LOCATION_Y),\r\n                        new Point(BLUE_BLOCK5_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_FOUNDATION_Y + 1)).setMaxDeceleration(0.015), PERIOD + 250));\r\n        BluePurePursuitCenter.addSegment(new PurePursuitSegment(\"drive to second sky stone\",\r\n                new PursuitPath(new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_FOUNDATION_Y + 1),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_BLOCK2_X, BLUE_RUNWAY_Y + OFF_SET),\r\n                        new Point(BLUE_BLOCK2_X, BLUE_BLOCK_LOCATION_Y - 1.5)).setMaxDeceleration(0.017), PERIOD));\r\n        BluePurePursuitCenter.addSegment(new PurePursuitSegment(\"second trip to foundation\",\r\n                new PursuitPath(new Point(BLUE_BLOCK2_X, BLUE_BLOCK_LOCATION_Y - 1.5),\r\n                        new Point(BLUE_BLOCK2_X, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_NEAR_X, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_NEAR_X + 5, BLUE_FOUNDATION_Y)).setMaxDeceleration(0.017), PERIOD));\r\n        BluePurePursuitCenter.addSegment(new PurePursuitSegment(\"drive to third sky stone\",\r\n                new PursuitPath(new Point(BLUE_FOUNDATION_NEAR_X + 5, BLUE_FOUNDATION_Y),\r\n                        new Point(BLUE_FOUNDATION_NEAR_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_BLOCK6_X + 2, BLUE_RUNWAY_Y + OFF_SET),\r\n                        new Point(BLUE_BLOCK6_X + 2, BLUE_BLOCK_LOCATION_Y - 1.5)).setMaxDeceleration(0.013), PERIOD));\r\n        BluePurePursuitCenter.addSegment(new PurePursuitSegment(\"last trip to foundation\",\r\n                new PursuitPath(new Point(BLUE_BLOCK6_X + 2, BLUE_BLOCK_LOCATION_Y - 1.5),\r\n                        new Point(BLUE_BLOCK6_X + 2, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X, BLUE_FOUNDATION_Y_2ND))\r\n                        .setMaxDeceleration(0.01)\r\n                        .setPointSpacing(1.0)\r\n                        .setPathSmoothing(0.5), PERIOD));\r\n    }\r\n\r\n    public final static Path BluePurePursuitRight = new Path(\"collect right sky stones on blue side\");\r\n\r\n    static {\r\n        BluePurePursuitRight.addSegment(new PurePursuitSegment(\"drive to first sky stone\",\r\n                new PursuitPath(\r\n                        new Point(0, 0),\r\n                        new Point(BLUE_BLOCK4_X, BLUE_BLOCK_LOCATION_Y))\r\n                        .setMaxAcceleration(0.01)\r\n                        .setMaxDeceleration(0.015), 0));\r\n        BluePurePursuitRight.addSegment(new PurePursuitSegment(\"first trip to foundation\",\r\n                new PursuitPath(new Point(BLUE_BLOCK4_X, BLUE_BLOCK_LOCATION_Y),\r\n                        new Point(BLUE_BLOCK4_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_FOUNDATION_Y))\r\n                        .setMaxDeceleration(0.015), PERIOD + 250));\r\n        BluePurePursuitRight.addSegment(new PurePursuitSegment(\"drive to second sky stone\",\r\n                new PursuitPath(new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_FOUNDATION_Y),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_BLOCK1_X, BLUE_RUNWAY_Y + OFF_SET),\r\n                        new Point(BLUE_BLOCK1_X, BLUE_BLOCK_LOCATION_Y - 2)).setMaxDeceleration(0.017), PERIOD));\r\n        BluePurePursuitRight.addSegment(new PurePursuitSegment(\"second trip to foundation\",\r\n                new PursuitPath(new Point(BLUE_BLOCK1_X, BLUE_BLOCK_LOCATION_Y - 2),\r\n                        new Point(BLUE_BLOCK1_X, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_NEAR_X, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_NEAR_X + 5, BLUE_FOUNDATION_Y)).setMaxDeceleration(0.017), PERIOD));\r\n        BluePurePursuitRight.addSegment(new PurePursuitSegment(\"drive to third sky stone\",\r\n                new PursuitPath(new Point(BLUE_FOUNDATION_NEAR_X + 5, BLUE_FOUNDATION_Y),\r\n                        new Point(BLUE_FOUNDATION_NEAR_X, BLUE_RUNWAY_Y),\r\n                        new Point(BLUE_BLOCK6_X + 2, BLUE_RUNWAY_Y + OFF_SET),\r\n                        new Point(BLUE_BLOCK6_X + 2, BLUE_BLOCK_LOCATION_Y - 2)).setMaxDeceleration(0.013), PERIOD));\r\n        BluePurePursuitRight.addSegment(new PurePursuitSegment(\"last trip to foundation\",\r\n                new PursuitPath(new Point(BLUE_BLOCK6_X + 2, BLUE_BLOCK_LOCATION_Y - 2),\r\n                        new Point(BLUE_BLOCK6_X + 2, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X, BLUE_RUNWAY_Y_2),\r\n                        new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X, BLUE_FOUNDATION_Y_2ND))\r\n                        .setMaxDeceleration(0.01)\r\n                        .setPointSpacing(1.0)\r\n                        .setPathSmoothing(0.5), PERIOD));\r\n\r\n    }\r\n\r\n    public final static Path BlueDragFoundation = new Path(\"Blue Drag Foundation\");\r\n\r\n    static {\r\n        BlueDragFoundation.addSegment(new PurePursuitSegment(\"Pull the foundation\", new PursuitPath(\r\n                new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X - 0, BLUE_FOUNDATION_Y_2ND + 0),\r\n                new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X - 20, BLUE_FOUNDATION_Y_2ND + 16))\r\n                .setMinSpeed(0.7)\r\n                .setTurnSpeed(1.0)\r\n                .setTurnGain(1.0)\r\n                .setPositionError(15.0)\r\n                .setHeadingError(10.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 1000, 55, 1500));\r\n        BlueDragFoundation.addSegment(new PurePursuitSegment(\"park the foundation\", new PursuitPath(\r\n                new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X - 20, BLUE_FOUNDATION_Y_2ND + 14),\r\n                new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X - 6, BLUE_FOUNDATION_Y_2ND + 8))\r\n                .setMinSpeed(1.1)\r\n                .setTurnSpeed(1.0)\r\n                .setTurnGain(3.0)\r\n                .setPositionError(15.0)\r\n                .setHeadingError(10.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0, 90, 1700));\r\n        BlueDragFoundation.addSegment(new PurePursuitSegment(\"park the robot\", new PursuitPath(\r\n                new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X - 14, BLUE_FOUNDATION_Y_2ND + 5),\r\n                new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X - 18, +BLUE_FOUNDATION_Y_2ND + 1),\r\n                new Point(BLUE_FOUNDATION_MIDDLE_NEAR_X - 50, BLUE_FOUNDATION_Y_2ND - 2))\r\n                .setMinSpeed(0.25)\r\n                .setMaxSpeed(0.6)\r\n                .setTurnSpeed(0.1)\r\n                .setTurnGain(1.0)\r\n                .setPositionError(6.0)\r\n                .setHeadingError(8.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0, 90, 3000));\r\n    }\r\n\r\n    public final static Path BlueDragFoundationTest = new Path(\"Blue Drag Foundation Test\");\r\n\r\n    static {\r\n        BlueDragFoundationTest.addSegment(new PurePursuitSegment(\"Pull the foundation\", new PursuitPath(\r\n                new Point(0, 0),\r\n                new Point(-20, +16))\r\n                .setMinSpeed(0.8)\r\n                .setTurnSpeed(1.0)\r\n                .setTurnGain(1.0)\r\n                .setPositionError(15.0)\r\n                .setHeadingError(10.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0, 55, 1600));\r\n        BlueDragFoundationTest.addSegment(new PurePursuitSegment(\"park the foundation\", new PursuitPath(\r\n                new Point(-20, +14),\r\n                new Point(-6, +8))\r\n                .setMinSpeed(1.0)\r\n                .setTurnSpeed(1.0)\r\n                .setTurnGain(2.0)\r\n                .setPositionError(15.0)\r\n                .setHeadingError(10.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0, 90, 1400));\r\n        BlueDragFoundationTest.addSegment(new PurePursuitSegment(\"park the robot\", new PursuitPath(\r\n                new Point(-14, +5),\r\n                new Point(-18, 1),\r\n                new Point(-50, -2))\r\n                .setMinSpeed(0.25)\r\n                .setMaxSpeed(0.6)\r\n                .setTurnSpeed(0.1)\r\n                .setTurnGain(1.0)\r\n                .setPositionError(6.0)\r\n                .setHeadingError(8.0)\r\n                .setPathSmoothing(0.5)\r\n                .setPointSpacing(1.0), 0, 90, 3000));\r\n\r\n//        BlueDragFoundationTest.addSegment(new PurePursuitSegment(\"park the foundation\", new PursuitPath(new Point(-20, +12), new Point(-17, +4)).setMinSpeed(0.3).setPositionError(4.0), 0, 90));\r\n//        BlueDragFoundationTest.addSegment(new PurePursuitSegment(\"park the robot\", new PursuitPath(new Point(- -17, +4), new Point(-26, +1), new Point(-48, +-2)).setMinSpeed(0.3).setPositionError(4.0), 0, 90));\r\n    }\r\n\r\n    public final static Path RedShortPath = new Path(\"park robot\");\r\n\r\n    static {\r\n        RedShortPath.addSegment(new PurePursuitSegment(\"Park\",\r\n                new PursuitPath(new Point(0, 0), new Point(RED_PARK_X, RED_PARK_Y))));\r\n    }\r\n\r\n    public final static Path BlueShortPath = new Path(\"park robot\");\r\n\r\n    static {\r\n        BlueShortPath.addSegment(new PurePursuitSegment(\"Park\",\r\n                new PursuitPath(new Point(0, 0), new Point(BLUE_PARK_X, BLUE_PARK_Y))));\r\n\r\n\r\n    }\r\n\r\n    public final static Path RedDistancePath = new Path(\"pick up first stone\");\r\n\r\n    static {\r\n        RedDistancePath.addSegment(new PurePursuitSegment(\"drive to first sky stone\",\r\n                new PursuitPath(new Point(0, 0),\r\n                        new Point(RED_BLOCK5_X+2, RED_BLOCK_LOCATION_Y+4)) .setMaxAcceleration(0.01),0,0,\r\n                                                                    10000,true));\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/hardware/AutonPursuitPaths.java	(revision a6e8d7abddb208c5e6740b3da665368e8ce3bf8a)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/mecanum/hardware/AutonPursuitPaths.java	(date 1582498154850)
@@ -675,6 +675,12 @@
     }
 
 
+
+
+
+
+
+
 }
 
 
